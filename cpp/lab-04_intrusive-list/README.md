# Лабораторная №4

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Интрузивный список](#интрузивный-список)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Прочие требования](#прочие-требования)
    1. [Консольные команды](#консольные-команды)
    1. [Структура репозитория](#структура-репозитория)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Возьмите файлы `clist.c` и `clist.h` из этого задания и закончите реализацию структуры данных
«интрузивный двусвязный список». Здесь слово «интрузивный» обозначает не алгоритм, а способ связи
данных и списка: не данные являются полем структуры «элемент списка», а структура «элемент списка»
является полем структуры «данные».

Затем возьмите файл `main.c` и дореализуйте в нём программу, которая хранит в интрузивном двусвязном
списке мультимножество точек на декартовой плоскости с целыми координатами. Программа должна
предоставлять интерактивный интерфейс командной строки (command line interface, CLI) для доступа к
списку. Сохранять точки куда-то, кроме динамической памяти, не требуется.

### Интрузивный список
*Подсказка:* реализовывать список с «фиктивным элементом» (который никогда
не удаляется) может быть проще.

Для использования интрузивного списка в `main.c` может быть полезен следующий макрос (стоит добавить
в `clist.h`):

```c
#define container_of(ptr, type, member) (type*)((char*)(ptr) - offsetof(type, member))
```

Макрос позволяет из указателя на элемент списка `ptr` получить указатель на структуру `type`,
в которой этот элемент лежит в поле `member`.

Пример использования:

```c
struct intrusive_node *list_head = /* ... */;
struct position_node *item = container_of(list_head, struct point, node);
```

**Важно:** Макрос `container_of` использует в свою очередь макрос `offsetof`, который объявлен в
заголовочном файле `stddef.h`. Перед объявлением макроса его нужно подключить. 

## Требования к корректности решения
### Стандартные требования
См. стандартные требования из третьей лабораторной.

Требования на автоматические тесты остаются, но неактуальны, потому что автоматические тесты
в задании реализовывать не надо.

Добавляются новые требования, которые будут актуальны во всех будущих лабораторных:

* При завершении работы программа должна освобождать всю динамически выделенную память (кучу, 
  `malloc`).
* В программе должны отсутствовать утечки памяти.
* Программа должна работать при любом корректном вводе, если иное не оговорено в задании.
  Например, при чтении используйте `fgets` вместо `gets`, чтобы обозначить максимально допустимый
  буфер, и `scanf("%239s", s)` вместо `scanf("%s", s)` (здесь `239` — максимальное количество
  символов, которые разрешается прочитать `scanf`). В противном случае вы можете получить
  переполнение буфера и undefined behavior.
* Запрещается творить дичь с жуткой арифметикой указателей. Рекомендуется `a[i]` вместо `*(a + i)`.
  Пишите читаемый код.

### Прочие требования
* Вы должны реализовать все предоставленные в заглушке функции, а также корректно расставить типы и
  имена.
* Запрещается «вручную» выполнять операции изменения списков вне файлов `clist.*` (например,
  переставлять указатели, чтобы вставить элемент). При этом просто пройтись по списку разрешается.
* Интрузивный список из файлов `clist.*` должен работать внутри произвольных типов, не только
  `struct point` из `main.c`. Это должно получиться автоматически, если вы никак не ссылаетесь
  на тип `struct point` из `clist.*`.

### Консольные команды
Каждая команда вводится на отдельной строчке стандартного ввода. Стандартная конвенция: первая часть
команды до пробела — это название операции, а остальное — аргументы.

* `add <x> <y>` — добавить точку `(x, y)` в **начало** списка.
* `rm <x> <y>` — удалить все точки `(x, y)` из списка.
* `print` — напечатать в одну строчку все точки, которые сейчас лежат в списке. Порядок важен,
  пробелы важны, точный формат смотрите в примерах. Вывод заканчивается переводом строки;
* `rma` — удалить все точки из списка.
* `len` — вывести на экран количество элементов в списке.
* `exit` — выйти из программы.
* Любая другая команда — печать сообщения `Unknown command`.

Гарантируется, что команда либо корректна, либо состоит из одного токена (название операции),
который не совпадает ни с одном из перечисленных выше. Например, команда `sort` может быть подана
на вход, а вот `add 10` или `sort 10 20` — уже нет.

Гарантируется, что все координаты помещаются в стандартный тип `int`.

Пример интерактивной сессии (каждый ввод завершается переводом строчки, каждый вывод, если 
происходит, тоже):

| Ввод     | Вывод                   |
|:---      |:---                     |
|`add 1 2` |                         |
|`add 3 6` |                         |
|`add 4 6` |                         |
|`len`     |`3`                      |
|`add 1 2` |                         |
|`print`   |`(1 2) (4 6) (3 6) (1 2)`|
|`sort`    |`Unknown command`        |
|`rm 1 2 ` |                         |
|`print`   |`(4 6) (3 6)`            |
|`rma`     |                         |
|`print`   | *‹пустая строчка›*      |
|`len`     |`0`                      |
|`add 2 -4`|                         |
|`print`   |`(2 -4)`                 |

Доступна [запись работы в терминале](https://asciinema.org/a/BIQKQq5YUsnUh7LUvKekQTT9g) для этого примера.
Также эту запись можно просмотреть с помощью команды `asciinema play cli-demo.asciinema`.

### Структура репозитория
```
<корень-личного-репозитория>
|--lab-04_intrusive-list
   |--include
   |  |-- clist.h
   |--src
   |  |-- clist.c
   |  |-- main.c
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Сроки сдачи

Уточняйте у своего преподавателя.
