# Лабораторная №14 (`WW_linq`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Примеры](#примеры)
    1. [Мотивация задания](#мотивация-задания)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Общая структура API](#общая-структура-api)
    1. [Поддерживаемые методы](#поддерживаемые-методы)
    1. [Поддерживаемые типы](#поддерживаемые-типы)
    1. [Smoke-тесты](#smoke-тесты)
    1. [Заголовчный файл](#заголовчный-файл)
    1. [Структура репозитория](#структура-репозитория)
1. [Предлагаемая архитектура](#предлагаемая-архитектура)
    1. [Предоставленный код](#предоставленный-код)
    1. [Разбор примера](#разбор-примера)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание
Вам требуется реализовать библиотеку из нескольких классов и функций, которая
бы позволила обрабатывать последовательные данные в одну несложную команду,
похожую по синтаксису на LINQ ([Fluent interface](https://ru.wikipedia.org/wiki/Fluent_interface))
и по духу — на потоки Java 8.

### Примеры
__Пример 1__:

```c++
int xs[] = { 1, 2, 3, 4, 5 };
std::vector<int> res =
  from(xs, xs + 5)  // Взять элементы xs
  .select([](int x) { return x * x; })  // Возвести в квадрат
  .where_neq(25)    // Оставить только значения != 25
  .where([](int x) { return x > 3; })   // Оставить только значения > 3
  .drop(2)          // Убрать два элемента из начала
  .to_vector();     // Преобразовать результат в вектор
```

__Пример 2__:

```c++
std::istream_iterator<int> in(std::cin), eof;
std::cout <<
  from(in, eof)  // Взять числа из входного потока
  .take(4)       // Не более четырёх чисел
  .until_eq(-1)  // Перестать читать после прочтения -1
  .to_vector();  // Получить список считанных чисел
```

__Пример 3__:
```c++
int xs[] = { 1, 2, 3, 4, 5 };
std::vector<double> res =
  from(xs, xs + 5)  // Взять элементы xs
  .select<double>([](int x) { return sqrt(x); })  // Извлечь корень
  .to_vector();     // Преобразовать результат в вектор
```

__Пример 4__:
```c++
std::istream_iterator<int> in(std::cin), eof;
std::ostream_iterator<double> out(std::cout, "\n");
from(in, eof)    // Взять числа из входного потока
.select([](int x) { return sqrt(x); })  // Извлечь из каждого корень
.copy_to(out);  // Вывести на экран
```

### Мотивация задания
__Этот раздел не требуется читать для понимания условия задания__.

Предположим, что у нас есть какая-то задача обработки списков/векторов/массивов.
Например, такая: имеется `vector<pair<int, string>> pages`, который содержит
любимые страницы пользователя. Первый элемент в паре — сколько раз эта страница
была посещена, второй — её адрес. Нам требуется получить адреса всех страниц,
которые никогда не посещались, и адреса которых начинаются с `https://vk.com/`.
На языке C++ эту задачу можно было бы решить так:

```c++
vector<string> result;
for (auto &page : pages) {
  if (page.first == 0 && page.second.find("https://vk.com/") == 0) {
    result.push_back(page.second);
  }
}}
```
К сожалению, это решение занимает довольно много места, а смысл оказывается
заключён в одной строчке с `if`.

В некоторых языках программирования в той или иной степени присутствуют
декларативные способы обработки данных, позволяющие записать подобные
манипуляции намного короче. Например:

```python
# Python
[ addr
  for (cnt, addr) in pages
  if cnt == 0 and addr.startswith("https://vk.com/") ]
```
```sql
-- SQL
SELECT addr
FROM pages
WHERE cnt = 0 AND addr LIKE 'https://vk.com/%'
```
```c#
// Встроенный в C# язык LINQ:
from page in pages
where (page.Item1 == 0) && (page.Item2.StartsWith("https://vk.com/"))
select page.Item2
```
```java
// Java 8
pages.stream().where((page) -> page.cnt == 0)
              .where((page) -> page.addr.startsWith("https://vk.com/"))
              .map((page) -> page.addr)
              .toList()
```
```kotlin
// Kotlin
pages
    .asSequence()
    .filter { it.cnt == 0 }
    .filter { it.addr.startsWith("https://vk.com") }
    .map { it.addr }
    .toList()
```

В этом задании вам потребуется реализовать похожий функционал в C++.
Цель — записывать несложные преобразования списков короче, чем циклами `for`,
и без использования дополнительных переменных.

## Требования к корректности решения
### Стандартные требования
Смотри стандартные требования из предыдущих заданий (они теперь доступны [в общей папке](../tasks-common)), название папки — `lab_14`.

В этом задании не требуется собирать исполняемые файлы и не требуется папка `src`,
но вы можете их добавить (смотри [структуру репозитория](#структура-репозитория)).

### Общая структура API
Идеологически мы составляем цепочку команд (как `echo | foo` в Bash), по которой
лениво передаются элементы.

При этом:

* Цепочка состоит из трёх принципиальных частей: одна команда генерации
  последовательности, ноль или более команд преобразований, одна завершающая
  команда (подробнее ниже).
* Пользователю библиотеки не разрешается разделять вычисление на несколько
  команд, всё должно быть сделано «от одной точки с запятой до следующей».
* В процессе вычислений могут использоваться произвольные копируемые типы.
  См. пример 3 — там `int` преобразуется в `double` командой `select`.
* В качестве входа (функция `from`) могут использоваться произвольные
  STL-подобные итераторы и контейнеры (за исключением `vector<bool>`), а также
  массивы.
* Вычисления должны производиться максимально «лениво».
  * Например, после запуска второго примера из входного потока должно
    быть считано не более четырёх чисел. А при запуске четвёртого примера
    результаты вычислений должны появляться на экране интерактивно, как только
    пользователь вводит числа.
  * Эталон ленивости — Haskell. Однако для простоты также разрешается
    использовать модель `std::istream_iterator`: выполнять какие-то действия
    в конструкторе и `operator++`, а в `operator*` доставать закэшированный
    результат.
* Функторы не должны копироваться внутри вашего кода.
  Если при передаче функтора в `select`/`until`/`where` его пришлось
  скопировать в момент вызова — это не ошибка.
* Все детали реализации и названия внутренних классов полностью должны быть
  скрыты от пользователя (должно получиться автоматически — никаких
  переменных с вашими классами пользователь создавать не должен).
* Командам, кроме `to_vector`, запрещается сохранять в себе все прошедшие
  через них элементы (иногда хотя бы один сохранять придётся).

### Поддерживаемые методы
1. Генерация последовательностей:
  * `template<typename T> ??? from(T begin, T end)` — генерирует
    последовательность из STL-полуинтервала `[begin; end)`.
  Исходный контейнер не должен изменяться никаким образом.
2. Преобразования последовательностей:
  * `.drop(count)` — удаляет из последовательности первые `count` элементов.
    Если последовательность была короче, она становится пустой.
  * `.take(count)` — оставляет в последовательности только первые `count`
    элементов. В частности, из-за ленивости элемент `count+1` никогда не должны
    быть запрошен у генератора последовательности.
    Если последовательность была короче, остаётся вся последовательность.
  * `.select(f)` — применяет функцию `f` к каждом элементу последовательности.
    `f` может изменять тип элемента — в таком случае требуется
    явное указание нового типа синтаксисом `.select<T>(f)` (как в примере 3).
    Вообще говоря, можно решить и без этого при помощи `decltype` и `std::declval<>`, но мы
    не будем.
  * `.until(f)` — обрывает последовательность, как только встретит элемент,
    удовлетворяющий предикату `f`, или если последовательность закончилась.
    В частности, из-за ленивости все последующие
    элементы никогда не должны спрашиваться у предыдущих команд.
  * `.until_eq(v)` обрывает последовательность, как только встретит элемент,
    равный `v`, или если последовательность закончилась.
  * `.where(f)` — оставляет в последовательности только те элементы, которые
    удовлетворяют предикату `f`. `f` — это произвольный функциональный
    объект (функция, функтор, лямбда).
  * `.where_neq(v)` — оставляет в последовательность только элементы, не равные
    `v`.
3. Терминальные команды:
  * `.to_vector()` — собирает все элементы в вектор и возвращает его.
  * `.copy_to(iter)` — копирует сгенерированную последовательность в
    STL-подобный итератор `iter` (аналогично алгоритму `std::copy`).
    Например, это может быть `ostream_iterator` (пример 4),
    `back_inserter` или обычный итератор (если мы заранее знаем количество
    элементов).

### Поддерживаемые типы
* Все элементы, возникающие в процессе вычислений, имеют тип с:
  * Конструктором по умолчанию.
  * Конструктором копирования и оператором присваивания.
  * Опционально: конструктором перемещения и оператором перемещающего присваивания.
    По возможности следует использоавть их.
* Все функторы поддерживают:
  * Вызов константного `operator()`.
  * Перемещение. Обратите внимание, что копирование может не поддерживаться (и в любом случае оно неэффективно и не требуется; это снижает баллы за стиль).

### Smoke-тесты
* Вам предоставлен файл `smoke_test.cpp` для _неполной_ проверки корректности
  решения. Если расположить его в папке `lab_15/src`, то следующая команда,
  запущенная из папки `lab_15`, должна завершиться успешно, если решение
  правильное:

  ```bash
  g++ -std=c++17 -pedantic -Wall -Wextra -Werror src/smoke_test.cpp -Iinclude -o smoke_test && ./smoke_test && echo OK
  ```

  Обратите внимание, что набор тестов _неполный_ и вам рекомендуется также
  написать свои.

* Также вам предоставлена урезанная версия `smoke_test.cpp` —
  `minimal_smoke_test.cpp`. Для получения ненулевого количества баллов
  требуется, чтобы этот файл компилировался и успешно выполнялся.

### Заголовочный файл
* Файл `linq.hpp` должен быть самодостаточен и не требовать никаких других
  файлов для компиляции и работы.
* Компиляция при тестировании будет производиться с ключом `-std=c++17` независимо
  от указанного в вашем `Makefile` (если он есть).
* Всё решение должно располагаться в `namespace linq`.
  * При этом требуется, чтобы непосредственно в `namespace linq` была
    вложена только функция `from` и, возможно, `namespace impl`.
    Это нужно, чтобы среда разработки после набора `linq::` подсказывала
    максимум один неправильный вариант.

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_15
   |--include
      |-- linq.hpp
   |--src
      |-- test.cpp
```

В файле test.cpp реализуйте main() с вызовом автоматических тестов. Вы можете добавить свои собственные тесты.
Таким образом при запуске исполняемого файла lab-14_linq должны вызываться все имеющиеся тесты.


## Предлагаемая архитектура
Ниже мы предлагаем вам структуру решения. Если вам хочется сделать совсем
по-другому или что-то кажется нелогичным — обсудите это с вашим преподавателем.

* Генерирующие команды — это функции, возвращающие некоторые
  классы (которые мы назовём «энумераторами»), которые как-то описывают
  сгенерированную последовательность.
* Каждый энумератор имеет полный набор методов для преобразовывающих и
  терминальных команд. Каждый такой метод возвращает новый энумератор.
* Так как все вызовы этих методов будут скомбинированы пользователем в рамках
  одного statement, мы можем не беспокоиться за время жизни и владение
  энумераторами и просто передавать их по значению/ссылкам — компилятор
  уничтожит временные объекты только после того, как вся цепочка отработает.
* Имеет смысл включить C++14, чтобы получить возможность писать `auto` вместо
  возвращаемых типов у функции.
* Имеет смысл сделать базовый класс «энумератор», чтобы избежать дублирования
  кода для `.where`/`.select`/`.copy_to` в разных энумераторах.
* Несмотря на то, что задание можно реализовать [целиком на шаблонах](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template)
  (и даже без дублирования кода), с виртуальными функциями решение будет несколько
  проще.
* Требуется по возможности избегать лишних копирований и лишних перемещений,
  не особо надеясь на догадливость оптимизатора.
* Требуется не сохранять объекты без необходимости — указатели или ссылки
  лучше (но помним про стандартные проблемы с ними).
* Запрещается вызывать предикат (для `.where` и пр.)/функцию трансформации
  (для `.select`) на одном элементе последовательности более одного раза.
  Считайте, что это очень дорогая операция, количество которых должно быть
  минимально.
* Мы предлагаем сделать интерфейс энумератора похожим на интерфейс итератора:
  * В любой момент энумератор либо указывает на какой-то определённый элемент,
    либо находится в состоянии «конец последовательности».
  * Проверить существование текущего элемента можно при помощи оператора `bool`.
  * Энумератор можно сдвинуть на следующий элемент оператором `++`. Заметьте,
    что в энумераторе для `.where()` такая операция может потребовать более,
    чем один сдвиг предыдущего в цепочке.
  * Получить константную ссылку на текущий элемент можно при помощи оператора
    `*`. Будет удобнее, если гарантируется, что вызов этого оператора не сделает
    ничего, кроме возврата ссылки (в частности, не будет двигать предыдущие
    энумераторы) — так поведение будет похоже на поведение `istream_iterator`.
* Настоятельно рекомендуется писать юнит-тесты для своей библиотеки.
* Настоятельно рекомендуется реализовывать группу методов `where_*` через
  `where` и лямбды. Аналогично для `until_*`.
* Для хранения функциональных объектов можно как использовать `std::function`,
  так и параметризовывать свои классы типом функционального объекта. Первый
  подход проще, но влечёт ещё один виртуальный вызов и динамическое
  выделение памяти. Второй подход не требует ни того, ни другого, но
  необязателен.

Предлагаемая заглушка для базового класса «энумератор» (в ней может не хватать
каких-то важных слов):

```c++
template<typename T>
class enumerator {
public:
  T operator*(); // Получает текущий элемент.
  ??? operator++();  // Переход к следующему элементу
  operator bool();  // Возвращает true, если есть текущий элемент
}
```

### Предоставленный код
Вы можете найти авторское решение с некоторыми удалёнными строками и словами
в файле `linq.hpp`. Там уже частично реализованы:

* `class enumerator` — вам требуется придумать корректную сигнатуру для
  первых трёх методов, реализовать уже написанные методы (у них сигнатура
  корректна) и дописать недостающие по аналогии.
* `class range_enumerator` — энумератор по STL-подобному полуинтервалу из
  двух итераторов. Дополнительные поля в этом классе (кроме `begin_` и
  `end_`) не требуются.
* Функция `from` — обёртка для удобного создания `range_enumerator`, в её
  реализации не хватает лишь шаблонных типов для `range_enumerator`.
* `class drop_enumerator` — заглушка для энумератора, получающегося из операции
  `.drop()`. `take` реализуется аналогично. Возможно, вам потребуется добавить
  объявления полей.
* `class select_enumerator` — заглушка для энумератора, получающегося из
  операции `.select()`.
* `class until_enumerator` — заглушка для энумератора, получающегося из операции
  `.until()`. Операция `.where()` должна получиться аналогично.
* Все конструкторы уже имеют удобную сигнатуру.

### Разбор примера
Возьмём пример 4:
```c++
std::ostream_iterator<double> out(std::cout, "\n");
from(in, eof)    // Взять числа из входного потока
.select([](int x) { return sqrt(x); })  // Извлечь из каждого корень
.copy_to(out);  // Вывести на экран
```

В вашей реализации может происходить следующее:
1. `from()` возвращает энумератор `range_enumerator` (назовём его `A`), который
  соответствует  итераторам `in` и `eof`. Когда у `A` запрашивают элемент,
  он переадресует этот вопрос итератору `in`.
2. Метод `range_enumerator::select()` возвращает `select_enumerator` (назовём
  его `B`), который при необходимости запрашивает элементы у `A`, извлекает
  корень, и подаёт на свой выход.
3. Метод `select_enumerator::copy_to()` не возвращает ничего, но начинает
  запрашивать у `B` элементы по одному и, как только удаётся получить очередной
  элемент, записывает его в итератор `out`.
4. Несмотря на то, что энумераторы `A` и `B` — временные объекты, они живут до
  тех пор, пока `copy_to` не закончит выполнение. В частности, они могут
  хранить друг на друга ссылки и не беспокоиться о выделении памяти.

# Сроки сдачи
Уточняйте у своего преподавателя.

# Система оценки
* Если структура папок в вашем репозитории не соответствует заданию или файл
  `minimal_smoke_compile.cpp` не компилируется, то вы автоматически получаете 0
  баллов. Вывод компилятора вам будет предоставлен. Дальнейшая проверка будет
  производиться только после исправления ошибок компиляции и структуры папок.
* Задание оценивается в 10 баллов:
  * От 0 до 2 баллов — за компилирующийся с [`minimal_smoke_test.cpp`](#smoke-тесты) код:
    * 1 балл, если компилируется и почти работает («почти» на усмотрение
      преподавателя).
    * 2 балла, если компилируется и корректно работает.
  * От 0 до 5 баллов — за корректность.
  * От 0 до 3 баллов — за стиль кода.
* Точные критерии оценки каждой из частей остаются на усмотрение преподавателя.
